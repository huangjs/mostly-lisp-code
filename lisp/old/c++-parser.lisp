(defmacro lexer-loop ((c stream lexer-block) &body body) 
  (let ((loop (gensym))) 
	`(macrolet ((c->token (char) 
				  `(when (char= ,',c ,char) 
					 (return-from ,',lexer-block (values ',(intern (string char)) nil)))) 
				(c->loop (char &body body) 
				  `(when (char= ,',c ,char) ,@body (go ,',loop))) 
				(member->loop (set &body body) 
				  `(when (or ,@(mapcar (lambda (mc) `(char= ,',c ,mc)) set)) 
					 ,@body 
					 (go ,',loop))) 
				(p->token (function &body body) 
				  `(when (,function ,',c) 
					 (return-from ,',lexer-block (progn ,@body)))) 
				(backtrack-if-not (seq &body non-backtrack-forms) 
				  (labels ((backtracker (seq) 
							 (if (null seq) 
								 `(return-from ,',lexer-block 
									(progn (loop for c in *backtrack* 
											  do (lexback c ,',stream)) 
										   ,@non-backtrack-forms)) 
								 (destructuring-bind (test &rest rest) 
									 seq 
								   (etypecase test 
									 (character 
									  `(when (char= ,',c ,test) 
										 (let ((,',c (lexin ,',stream nil nil))) 
										   (push ,',c *backtrack*) 
										   (when ,',c ,(backtracker rest)) 
										   (lexback ','c ,',stream)))) 
									 (symbol 
									  `(when (,test ,',c) 
										 (let ((,',c (lexin ,',stream nil nil))) 
										   (push ,',c *backtrack*) 
										   (when ,',c ,(backtracker rest)) 
										   (lexback ','c ,',stream))))))))) 
					`(let ((*backtrack* nil)) 
					   (push ,',c *backtrack*) 
					   ,(backtracker seq)))) 
				(ctree->token (tree) 
				  (labels ((build-tree (tree &optional path) 
							 (if (atom tree) 
								 `(when (char= ,',c ,tree) 
									(return-from ,',lexer-block 
									  (values ',(intern (coerce (append path (list tree)) 
																'string)) 
											  nil))) 
								 (destructuring-bind (first &rest branches) 
									 tree 
								   `(when (char= ,',c ,first) 
									  (let ((,',c (lexin ,',stream nil nil))) 
										(when ,',c 
										  ,@(loop for branch in branches 
											   with new-path = (append path (list first)) 
											   collect (build-tree branch new-path))) 
										(lexback ,',c ,',stream) 
										(return-from ,',lexer-block 
										  (values ',(intern (coerce (append path (list 
																				  first)) 'string)) 
												  nil)))))))) 
					(build-tree tree)))) 
	   (prog (,c) 
		  ,loop 
		  (setf ,c (lexin ,stream)) 
		  ,@body)))) 

(defun top-level-lexer (stream) 
  (handler-case 
	  (lexer-loop (c stream top-level-lexer) 
		(member->loop (#\space #\tab #\newline #\cr #\ff)) 
		(c->loop #\# (lexdirective stream)) 
		(c->loop #\/ (lexcomment stream)) 
		(p->token start-symbol-char-p (lexback c stream) (lexsymbol stream)) 
		(backtrack-if-not (#\. digit-char-p) (lexnumber stream)) 
		(p->token digit-char-p (lexback c stream) (lexnumber stream)) 
		(c->token #\() 
		(c->token #\)) 
		(c->token #\[) 
		(c->token #\]) 
		(c->token #\{) 
		(c->token #\}) 
		(c->token #\;) 
		(c->token #\,) 
		(c->token #\.) 
		(ctree->token (#\: #\:)) 
		(ctree->token (#\+ #\+ #\=)) 
		(ctree->token (#\- #\- #\= #\>)) 
		(ctree->token (#\* #\=)) 
		(ctree->token (#\/ #\=)) 
		(ctree->token (#\% #\=)) 
		(ctree->token (#\> (#\> #\=) #\=)) 
		(ctree->token (#\< (#\< #\=) #\=)) 
		(ctree->token (#\& #\& #\=)) 
		(ctree->token (#\| #\| #\=)) 
		(ctree->token (#\= #\=)) 
		(ctree->token (#\^ #\=)) 
		(ctree->token (#\! #\=))) 

	(end-of-file () (values nil nil)))) 

