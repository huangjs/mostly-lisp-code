(defconstant +WIDTH+ 640)
(defconstant +HEIGHT+ 480)
(defconstant +CA-WIDTH+ (+ +WIDTH+ 2))
(defconstant +CA-HEIGHT+ (+ +HEIGHT+ 2))
(defconstant +CA-WIDTH+1+ (+ +CA-WIDTH+ 1))
(defconstant +WIDTH-1+ (- +WIDTH+ 1))
(defconstant +HEIGHT-1+ (- +HEIGHT+ 1))

(deftype ca-world () `(simple-array (unsigned-byte 8) (,(* +CA-WIDTH+
														   +CA-HEIGHT+))))
(deftype ca-index () `(integer 0 (mod ,(* +CA-WIDTH+ +CA-HEIGHT+))))

(declaim (inline sum-neighbours))
(defun sum-neighbours (array pos)
  (declare (optimize (speed 3)))
  (declare (type ca-world array)
           (type (integer #.+CA-WIDTH+1+ #.(+ +CA-WIDTH+1+ (* +HEIGHT+
															  +WIDTH+))) pos))
  (+ (aref array (1+ pos))
     (aref array (1- pos))
     (aref array (+ pos +CA-WIDTH+ -1))
     (aref array (+ pos +CA-WIDTH+))
     (aref array (+ pos +CA-WIDTH+ 1))
     (aref array (- pos +CA-WIDTH+ 1))
     (aref array (- pos +CA-WIDTH+))
     (aref array (- pos +CA-WIDTH+ -1))))

(declaim (inline loop-body))
(defun loop-body (ca1 ca2)
  (declare (inline sum-neighbours))
  (declare (optimize (speed 3)))
  (declare (type ca-world ca1 ca2))
  (let ((i +CA-WIDTH+1+))
    (dotimes (y +HEIGHT+)
      (dotimes (x +WIDTH+)
        (let ((cell (aref ca1 i)))
          (if (= cell 0)
              (if (= (sum-neighbours ca1 i) 1)
                  (setf (aref ca2 i) 1)
                  (setf (aref ca2 i) cell))
              (if (= cell 62)
                  (setf (aref ca2 i) 0)
                  (setf (aref ca2 i) (1+ cell)))))
        (incf i))
      (incf i 2))))

(defun main-loop (num-loops)
  (declare (optimize (speed 3)))
  (declare (notinline loop-body))
  (let ((ca1 (make-array (* +CA-WIDTH+ +CA-HEIGHT+)
                         :element-type '(unsigned-byte 8)
                         :initial-element 0))
        (ca2 (make-array (* +CA-WIDTH+ +CA-HEIGHT+)
                         :element-type '(unsigned-byte 8)
                         :initial-element 0)))
    (setf (aref ca1 (- (/ (* +CA-WIDTH+ +CA-HEIGHT+) 2) +CA-WIDTH+ 4))
          1)
    (loop repeat num-loops
	   do (loop-body ca1 ca2)
	   (rotatef ca1 ca2))
    ca1))

(defun call-main (num-loops)
  (let ((ca1 nil))
    (time
     (setf ca1 (main-loop num-loops)))
    (with-open-file (f "lisplog.txt" :direction :output :element-type
                       '(unsigned-byte 8) :if-exists :supersede)
      (write-sequence ca1 f))
    0))

;;(call-main 1000) 
